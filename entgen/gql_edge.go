// Code generated by ent, DO NOT EDIT.

package entgen

import (
	"context"

	"github.com/99designs/gqlgen/graphql"
)

func (pr *Profile) Owner(ctx context.Context) (*User, error) {
	result, err := pr.Edges.OwnerOrErr()
	if IsNotLoaded(err) {
		result, err = pr.QueryOwner().Only(ctx)
	}
	return result, err
}

func (pr *Profile) Tenant(ctx context.Context) (*Tenant, error) {
	result, err := pr.Edges.TenantOrErr()
	if IsNotLoaded(err) {
		result, err = pr.QueryTenant().Only(ctx)
	}
	return result, err
}

func (t *Tenant) Members(
	ctx context.Context, after *Cursor, first *int, before *Cursor, last *int, where *UserWhereInput,
) (*UserConnection, error) {
	opts := []UserPaginateOption{
		WithUserFilter(where.Filter),
	}
	totalCount := t.Edges.totalCount[0]
	if nodes, err := t.Edges.MembersOrErr(); err == nil || totalCount != nil {
		conn := &UserConnection{Edges: []*UserEdge{}}
		if totalCount != nil {
			conn.TotalCount = *totalCount
		}
		pager, err := newUserPager(opts)
		if err != nil {
			return nil, err
		}
		conn.build(nodes, pager, after, first, before, last)
		return conn, nil
	}
	query := t.QueryMembers()
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUserPager(opts)
	if err != nil {
		return nil, err
	}
	if query, err = pager.applyFilter(query); err != nil {
		return nil, err
	}
	conn := &UserConnection{Edges: []*UserEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
			if totalCount != nil {
				conn.TotalCount = *totalCount
			} else if conn.TotalCount, err = query.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := query.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	query = pager.applyCursors(query, after, before)
	query = pager.applyOrder(query, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		query.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := query.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := query.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

func (t *Tenant) MemberProfiles(
	ctx context.Context, after *Cursor, first *int, before *Cursor, last *int, where *ProfileWhereInput,
) (*ProfileConnection, error) {
	opts := []ProfilePaginateOption{
		WithProfileFilter(where.Filter),
	}
	totalCount := t.Edges.totalCount[1]
	if nodes, err := t.Edges.MemberProfilesOrErr(); err == nil || totalCount != nil {
		conn := &ProfileConnection{Edges: []*ProfileEdge{}}
		if totalCount != nil {
			conn.TotalCount = *totalCount
		}
		pager, err := newProfilePager(opts)
		if err != nil {
			return nil, err
		}
		conn.build(nodes, pager, after, first, before, last)
		return conn, nil
	}
	query := t.QueryMemberProfiles()
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProfilePager(opts)
	if err != nil {
		return nil, err
	}
	if query, err = pager.applyFilter(query); err != nil {
		return nil, err
	}
	conn := &ProfileConnection{Edges: []*ProfileEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
			if totalCount != nil {
				conn.TotalCount = *totalCount
			} else if conn.TotalCount, err = query.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := query.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	query = pager.applyCursors(query, after, before)
	query = pager.applyOrder(query, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		query.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := query.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := query.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

func (u *User) Profiles(
	ctx context.Context, after *Cursor, first *int, before *Cursor, last *int, where *ProfileWhereInput,
) (*ProfileConnection, error) {
	opts := []ProfilePaginateOption{
		WithProfileFilter(where.Filter),
	}
	totalCount := u.Edges.totalCount[0]
	if nodes, err := u.Edges.ProfilesOrErr(); err == nil || totalCount != nil {
		conn := &ProfileConnection{Edges: []*ProfileEdge{}}
		if totalCount != nil {
			conn.TotalCount = *totalCount
		}
		pager, err := newProfilePager(opts)
		if err != nil {
			return nil, err
		}
		conn.build(nodes, pager, after, first, before, last)
		return conn, nil
	}
	query := u.QueryProfiles()
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProfilePager(opts)
	if err != nil {
		return nil, err
	}
	if query, err = pager.applyFilter(query); err != nil {
		return nil, err
	}
	conn := &ProfileConnection{Edges: []*ProfileEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
			if totalCount != nil {
				conn.TotalCount = *totalCount
			} else if conn.TotalCount, err = query.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := query.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	query = pager.applyCursors(query, after, before)
	query = pager.applyOrder(query, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		query.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := query.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := query.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

func (u *User) Tenants(ctx context.Context) ([]*Tenant, error) {
	result, err := u.Edges.TenantsOrErr()
	if IsNotLoaded(err) {
		result, err = u.QueryTenants().All(ctx)
	}
	return result, err
}
